(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{432:function(e,t,a){"use strict";a.r(t);var i=a(42),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"omnistone"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#omnistone"}},[e._v("#")]),e._v(" Omnistone")]),e._v(" "),a("ul",[a("li",[e._v("Type: "),a("Badge",{attrs:{text:"Pyot Cache",vertical:"middle"}})],1),e._v(" "),a("li",[e._v("Description: A temporary Cache that starts on Pyot Settings activation and shut down on script or server exit. Since it lives at runtime it is a lot faster than an independent Cache server.")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("INFO ABOUT THIS STORE")]),e._v(" "),a("p",[e._v("This Cache doesn't expire data after it is "),a("em",[e._v("expired")]),e._v(". To prevent memory overflow, a cull system is in place. When the amount of data reaches a limit, it calls the "),a("code",[e._v("expire()")]),e._v(" coroutine on its own. If the amount of data is still higher than "),a("code",[e._v("MAX_ENTRIES")]),e._v(" * (1 - 1/"),a("code",[e._v("CULL_FRECUENCY")]),e._v("), it deletes items until the set amount. Deletion prioritizes least recently used data.")])]),e._v(" "),a("h2",{attrs:{id:"pipeline-settings-reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pipeline-settings-reference"}},[e._v("#")]),e._v(" Pipeline Settings Reference")]),e._v(" "),a("h3",{attrs:{id:"backend-pyot-stores-omnistone"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backend-pyot-stores-omnistone"}},[e._v("#")]),e._v(" Backend: "),a("code",[e._v("pyot.stores.Omnistone")])]),e._v(" "),a("h3",{attrs:{id:"arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arguments"}},[e._v("#")]),e._v(" Arguments:")]),e._v(" "),a("blockquote",[a("h4",{attrs:{id:"expirations-dict-str-any-none"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expirations-dict-str-any-none"}},[e._v("#")]),e._v(" "),a("code",[e._v("expirations: Dict[str, Any] = None")])]),e._v(" "),a("p",[e._v("Custom mapping for overriding the default expirations. For details and defaults refer to Pipeline > Store Bases > Expirations section.")]),e._v(" "),a("h4",{attrs:{id:"max-entries-int-10000"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#max-entries-int-10000"}},[e._v("#")]),e._v(" "),a("code",[e._v("max_entries: int = 10000")])]),e._v(" "),a("p",[e._v("The maximum amount of items to hold before expiring")]),e._v(" "),a("h4",{attrs:{id:"cull-frecuency-int-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cull-frecuency-int-2"}},[e._v("#")]),e._v(" "),a("code",[e._v("cull_frecuency: int = 2")])]),e._v(" "),a("p",[e._v("The 1/x ratio of max_entries to be culled in case it still passes this amount after expiring. Manual expiring will not trigger culling.")]),e._v(" "),a("h4",{attrs:{id:"log-level-int-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#log-level-int-10"}},[e._v("#")]),e._v(" "),a("code",[e._v("log_level: int = 10")])]),e._v(" "),a("p",[e._v("Set the log level for the store. Defaults to 10 (DEBUG level).")])]),e._v(" "),a("h2",{attrs:{id:"cached-endpoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cached-endpoints"}},[e._v("#")]),e._v(" Cached Endpoints")]),e._v(" "),a("p",[e._v("All available endpoints defined in the "),a("RouterLink",{attrs:{to:"/pipeline/expiration.html#default-expirations"}},[e._v("default expirations")]),e._v(". Endpoints are also documented under each service store documentation.")],1)])}),[],!1,null,null,null);t.default=s.exports}}]);